{
	// Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Insertion Sort ": {
		"prefix": "insort",
		"body": [
		  "void swap(int *xp, int *yp)",
		  "{",
		  "\tint temp = *xp;",
		  "\t*xp = *yp;",
		  "\t*yp = temp;",
		  "}",
		  "",
		  "void insertionSort(int a[], int n)",
		  "{",
		  "\tint key;",
		  "\tfor (int i = 1; i < n; i++)",
		  "\t{",
		  "\t\tkey = a[i];",
		  "\t\tint j = i - 1;",
		  "\t\twhile (j >= 0 && a[j] > key)",
		  "\t\t{",
		  "\t\t\ta[j + 1] = a[j];",
		  "\t\t\tj--;",
		  "\t\t}",
		  "\t\ta[j + 1] = key;",
		  "\t}",
		  "}",
		  "//int main()",
		  "//{",
		  "\tint n;",
		  "\tcin >> n;",
		  "\tint a[n];",
		  "\tfor (int i = 0; i < n; i++)",
		  "\t{",
		  "\t\tcin >> a[i];",
		  "\t}",
		  "\tinsertionSort(a, n);",
		  "\tfor (int i = 0; i < n; i++)",
		  "\t{",
		  "\t\tcout << a[i] << \" \";",
		  "\t}",
		  "//return 0;",
		  "//}"
		],
		"description": "Insertion Sort "
	  },
	"Bubble Sort ": {
	"prefix": "bubsort",
	"body": [
		"void swap(int *xp, int *yp)",
		"{",
		"\tint temp = *xp;",
		"\t*xp = *yp;",
		"\t*yp = temp;",
		"}",
		"",
		"void recurBubbleSort(int arr[], int n)",
		"{",
		"\t// Base case",
		"\tif (n == 1)",
		"\t\treturn;",
		"",
		"\t// One pass of bubble sort. After",
		"\t// this pass, the largest element",
		"\t// is moved (or bubbled) to end.",
		"\tfor (int i = 0; i < n - 1; i++)",
		"\t\tif (arr[i] > arr[i + 1])",
		"\t\t\tswap(arr[i], arr[i + 1]);",
		"",
		"\t// Largest element is fixed,",
		"\t// recur for remaining array",
		"\tbubbleSort(arr, n - 1);",
		"}",
		"",
		"void bubbleSort(int a[], int n)",
		"{",
		"\tfor (int i = 0; i < n - 1; i++)",
		"\t{",
		"\t\tbool flag = false;",
		"\t\tfor (int j = 0; j < n - i - 1; j++)",
		"\t\t{",
		"\t\t\tif (a[j] > a[j + 1])",
		"\t\t\t{",
		"\t\t\t\tswap(&a[j], &a[j + 1]);",
		"\t\t\t\tflag = true;",
		"\t\t\t}",
		"\t\t}",
		"\t\tif (flag == false)",
		"\t\t{",
		"\t\t\tbreak;",
		"\t\t}",
		"\t}",
		"}",
		"int main()",
		"{",
		"\tint n;",
		"\tcin >> n;",
		"\tint a[n];",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcin >> a[i];",
		"\t}",
		"\tbubbleSort(a, n);",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcout << a[i] << \" \";",
		"\t}",
		"\treturn 0;",
		"}"
	],
	"description": "Bubble Sort "
	},
	"Selection Sort ": {
	"prefix": "selsort",
	"body": [
		"void swap(int *xp, int *yp)",
		"{",
		"\tint temp = *xp;",
		"\t*xp = *yp;",
		"\t*yp = temp;",
		"}",
		"",
		"void selectionSort(int a[], int n)",
		"{",
		"\tint min_idx;",
		"\tfor (int i = 0; i < n - 1; i++)",
		"\t{",
		"\t\tmin_idx = i;",
		"\t\tfor (int j = i + 1; j < n; j++)",
		"\t\t{",
		"\t\t\tif (a[min_idx] > a[j])",
		"\t\t\t{",
		"\t\t\t\tmin_idx = j;",
		"\t\t\t}",
		"\t\t}",
		"\t\tswap(&a[min_idx], &a[i]);",
		"\t}",
		"}",
		"int main()",
		"{",
		"\tint n;",
		"\tcin >> n;",
		"\tint a[n];",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcin >> a[i];",
		"\t}",
		"\tselectionSort(a, n);",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcout << a[i] << \" \";",
		"\t}",
		"\treturn 0;",
		"}"
	],
	"description": "Selection Sort "
	},
	"Merge Sort ": {
	"prefix": "mersort",
	"body": [
		"void swap(int *xp, int *yp)",
		"{",
		"\tint temp = *xp;",
		"\t*xp = *yp;",
		"\t*yp = temp;",
		"}",
		"void merge(int array[], int const left, int const mid, int const right)",
		"{",
		"\tauto const subArrayOne = mid - left + 1;",
		"\tauto const subArrayTwo = right - mid;",
		"",
		"\t// Create temp arrays",
		"\tauto *leftArray = new int[subArrayOne],",
		"\t\t *rightArray = new int[subArrayTwo];",
		"",
		"\t// Copy data to temp arrays leftArray[] and rightArray[]",
		"\tfor (auto i = 0; i < subArrayOne; i++)",
		"\t\tleftArray[i] = array[left + i];",
		"\tfor (auto j = 0; j < subArrayTwo; j++)",
		"\t\trightArray[j] = array[mid + 1 + j];",
		"",
		"\tauto indexOfSubArrayOne = 0,   // Initial index of first sub-array",
		"\t\tindexOfSubArrayTwo = 0;\t// Initial index of second sub-array",
		"\tint indexOfMergedArray = left; // Initial index of merged array",
		"",
		"\t// Merge the temp arrays back into array[left..right]",
		"\twhile (indexOfSubArrayOne < subArrayOne && indexOfSubArrayTwo < subArrayTwo)",
		"\t{",
		"\t\tif (leftArray[indexOfSubArrayOne] <= rightArray[indexOfSubArrayTwo])",
		"\t\t{",
		"\t\t\tarray[indexOfMergedArray] = leftArray[indexOfSubArrayOne];",
		"\t\t\tindexOfSubArrayOne++;",
		"\t\t}",
		"\t\telse",
		"\t\t{",
		"\t\t\tarray[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];",
		"\t\t\tindexOfSubArrayTwo++;",
		"\t\t}",
		"\t\tindexOfMergedArray++;",
		"\t}",
		"\t// Copy the remaining elements of",
		"\t// left[], if there are any",
		"\twhile (indexOfSubArrayOne < subArrayOne)",
		"\t{",
		"\t\tarray[indexOfMergedArray] = leftArray[indexOfSubArrayOne];",
		"\t\tindexOfSubArrayOne++;",
		"\t\tindexOfMergedArray++;",
		"\t}",
		"\t// Copy the remaining elements of",
		"\t// right[], if there are any",
		"\twhile (indexOfSubArrayTwo < subArrayTwo)",
		"\t{",
		"\t\tarray[indexOfMergedArray] = rightArray[indexOfSubArrayTwo];",
		"\t\tindexOfSubArrayTwo++;",
		"\t\tindexOfMergedArray++;",
		"\t}",
		"}",
		"",
		"// begin is for left index and end is",
		"// right index of the sub-array",
		"// of arr to be sorted */",
		"void mergeSort(int array[], int const begin, int const end)",
		"{",
		"\tif (begin >= end)",
		"\t\treturn; // Returns recursively",
		"",
		"\tauto mid = begin + (end - begin) / 2;",
		"\tmergeSort(array, begin, mid);",
		"\tmergeSort(array, mid + 1, end);",
		"\tmerge(array, begin, mid, end);",
		"}",
		"int main()",
		"{",
		"\tint n;",
		"\tcin >> n;",
		"\tint a[n];",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcin >> a[i];",
		"\t}",
		"\tmergeSort(a, 0, n - 1);",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcout << a[i] << \" \";",
		"\t}",
		"\treturn 0;",
		"}"
	],
	"description": "Merge Sort "
	},
	"Quick Sort ": {
	"prefix": "qsort",
	"body": [
		"void swap(int *xp, int *yp)",
		"{",
		"\tint temp = *xp;",
		"\t*xp = *yp;",
		"\t*yp = temp;",
		"}",
		"int partition(int a[], int l, int h)",
		"{",
		"\tint i = l;",
		"\tint j = h;",
		"\tint pivot = a[l];",
		"\twhile (i < j)",
		"\t{",
		"\t\tdo",
		"\t\t{",
		"\t\t\ti++;",
		"\t\t} while (a[i] <= pivot);",
		"\t\tdo",
		"\t\t{",
		"\t\t\tj--;",
		"\t\t} while (a[j] > pivot);",
		"\t\tif (i < j)",
		"\t\t{",
		"\t\t\tswap(&a[i], &a[j]);",
		"\t\t}",
		"\t}",
		"\tswap(&a[l], &a[j]);",
		"\treturn j;",
		"}",
		"void quickSort(int a[], int l, int h)",
		"{",
		"\tif (l < h)",
		"\t{",
		"\t\tint pi = partition(a, l, h);",
		"\t\tquickSort(a, l, pi);",
		"\t\tquickSort(a, pi + 1, h);",
		"\t}",
		"}",
		"int main()",
		"{",
		"\tint n;",
		"\tcin >> n;",
		"\tint a[n];",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcin >> a[i];",
		"\t}",
		"\tquickSort(a, 0, n - 1);",
		"\tfor (int i = 0; i < n; i++)",
		"\t{",
		"\t\tcout << a[i] << \" \";",
		"\t}",
		"\treturn 0;",
		"}"
	],
	"description": "Quick Sort "
	}
}