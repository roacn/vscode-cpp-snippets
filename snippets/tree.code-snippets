{
"Tree Structure": {
"prefix": "tstruct",
"body": [
"struct Node",
"{",
"\tint data;",
"\tNode *left;",
"\tNode *right;",
"",
"\tNode(int k)",
"\t{",
"\t\tdata = k;",
"\t\tleft = right = NULL;",
"\t}",
"};"
],
"description": "Tree Structure"
},
"Tree Inorder": {
"prefix": "inorder",
"body": [
"void inOrder(Node *temp)",
"{",
"\tif (temp != NULL)",
"\t{",
"\t\tinOrder(temp->left);",
"\t\tcout << temp->data << ' ';",
"\t\tinOrder(temp->right);",
"\t}",
"}"
],
"description": "Tree Inorder"
},
"Tree Preorder": {
"prefix": "preorder",
"body": [
"void preOrder(Node *temp)",
"{",
"\tif (temp != NULL)",
"\t{",
"\t\tcout << temp->data << ' ';",
"\t\tpreOrder(temp->left);",
"\t\tpreOrder(temp->right);",
"\t}",
"}"
],
"description": "Tree Preorder"
},
"Tree Postorder": {
"prefix": "postorder",
"body": [
"int c = 0;",
"void postOrder(Node *temp)",
"{",
"\tif (temp != NULL)",
"\t{",
"\t\tpostOrder(temp->left);",
"\t\tpostOrder(temp->right);",
"\t\tcout << temp->data << ' ';",
"\t\tif (temp->right == NULL && temp->left == NULL)",
"\t\t{",
"\t\t\tc++;",
"\t\t}",
"\t}",
"}"
],
"description": "Tree Postorder"
},
"Level Order Traversal Tree": {
"prefix": "levelOrder",
"body": [
"void levelOrder(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn;",
"\t}",
"\tqueue<Node *> q;",
"",
"\tq.push(root);",
"\tq.push(NULL);",
"",
"\twhile (!q.empty())",
"\t{",
"\t\tNode *node = q.front();",
"\t\tq.pop();",
"",
"\t\tif (node != NULL)",
"\t\t{",
"\t\t\tcout << node->data << \" \";",
"\t\t\tif (node->left)",
"\t\t\t{",
"\t\t\t\tq.push(node->left);",
"\t\t\t}",
"\t\t\tif (node->right)",
"\t\t\t{",
"\t\t\t\tq.push(node->right);",
"\t\t\t}",
"\t\t}",
"\t\telse if (!q.empty())",
"\t\t{",
"\t\t\tq.push(NULL);",
"\t\t}",
"\t}",
"}"
],
"description": "Level Order Traversal Tree"
},
"Tree Size": {
"prefix": "treeSize",
"body": [
"int getSize(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn 0;",
"\t}",
"\treturn 1 + getSize(root->left) + getSize(root->right);",
"}"
],
"description": "Tree Size"
},
"Tree Height": {
"prefix": "treeHeight",
"body": [
"int height(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn 0;",
"\t}",
"\treturn max(height(root->left), height(root->right)) + 1;",
"}"
],
"description": "Tree Height"
},
"Tree Simple Diameter": {
"prefix": "treeDiaSimple",
"body": [
"int diameter(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn 0;",
"\t}",
"",
"\tint currDiameter = height(root->left) + height(root->right) + 1;",
"",
"\tint lD = diameter(root->left);",
"\tint rD = diameter(root->right);",
"",
"\treturn max(currDiameter, max(lD, rD));",
"}"
],
"description": "Tree Simple Diameter"
},
"Tree Optimized Diameter": {
"prefix": "treeDiaOpt",
"body": [
"int optDiameter(Node *root, int *ht)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\t*ht = 0;",
"\t\treturn 0;",
"\t}",
"",
"\tint lh = 0, rh = 0;",
"",
"\tint lD = optDiameter(root->left, &lh);",
"\tint rD = optDiameter(root->right, &rh);",
"\tint currDiameter = lh + rh + 1;",
"\t*ht = max(lh, rh) + 1;",
"",
"\treturn max(currDiameter, max(lD, rD));",
"}"
],
"description": "Tree Optimized Diameter"
},
"Tree Node Sum": {
"prefix": "treeSum",
"body": [
"int getSum(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn 0;",
"\t}",
"\treturn getSum(root->left) + getSum(root->right) + root->data;",
"}"
],
"description": "Tree Node Sum"
},
"Tree Node Maximum": {
"prefix": "treeMax",
"body": [
"int MAX(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn INT_MIN;",
"\t}",
"",
"\treturn max(root->data, max(MAX(root->left), MAX(root->right)));",
"}"
],
"description": "Tree Node Maximum"
},
"Tree Right View": {
"prefix": "treeRightView",
"body": [
"void rightView(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn;",
"\t}",
"\tqueue<Node *> q;",
"\tq.push(root);",
"",
"\twhile (!q.empty())",
"\t{",
"\t\tint n = q.size();",
"\t\tfor (int i = 0; i < n; i++)",
"\t\t{",
"\t\t\tNode *curr = q.front();",
"\t\t\tq.pop();",
"",
"\t\t\tif (i == n - 1)",
"\t\t\t{",
"\t\t\t\tcout << curr->data << \" \";",
"\t\t\t}",
"\t\t\tif (curr->left != NULL)",
"\t\t\t{",
"\t\t\t\tq.push(curr->left);",
"\t\t\t}",
"\t\t\tif (curr->right != NULL)",
"\t\t\t{",
"\t\t\t\tq.push(curr->right);",
"\t\t\t}",
"\t\t}",
"\t}",
"}"
],
"description": "Tree Right View"
},
"Tree Left View": {
"prefix": "treeLeftView",
"body": [
"void leftView(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn;",
"\t}",
"\tqueue<Node *> q;",
"\tq.push(root);",
"",
"\twhile (!q.empty())",
"\t{",
"\t\tint n = q.size();",
"\t\tfor (int i = 1; i <= n; i++)",
"\t\t{",
"\t\t\tNode *curr = q.front();",
"\t\t\tq.pop();",
"",
"\t\t\tif (i == 1)",
"\t\t\t{",
"\t\t\t\tcout << curr->data << \" \";",
"\t\t\t}",
"\t\t\tif (curr->left != NULL)",
"\t\t\t{",
"\t\t\t\tq.push(curr->left);",
"\t\t\t}",
"\t\t\tif (curr->right != NULL)",
"\t\t\t{",
"\t\t\t\tq.push(curr->right);",
"\t\t\t}",
"\t\t}",
"\t}",
"}"
],
"description": "Tree Left View"
},
"Tree Balanced or Not Simple": {
"prefix": "isBalancedSimple",
"body": [
"bool isBalanced(Node *root)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn true;",
"\t}",
"\tif (isBalanced(root->left) == false)",
"\t{",
"\t\treturn false;",
"\t}",
"\tif (isBalanced(root->right) == false)",
"\t{",
"\t\treturn false;",
"\t}",
"\tif (abs(height(root->left) - height(root->right)) <= 1)",
"\t{",
"\t\treturn true;",
"\t}",
"\telse",
"\t{",
"\t\treturn false;",
"\t}",
"}"
],
"description": "Tree Balanced or Not Simple"
},
"Tree Balanced or Not Optimized": {
"prefix": "isBalancedOpt",
"body": [
"bool isOptBalanced(Node *root, int *ht)",
"{",
"\tif (root == NULL)",
"\t{",
"\t\treturn true;",
"\t}",
"\tint lh = 0, rh = 0;",
"\tif (isOptBalanced(root->left, &lh) == false)",
"\t{",
"\t\treturn false;",
"\t}",
"\tif (isOptBalanced(root->right, &rh) == false)",
"\t{",
"\t\treturn false;",
"\t}",
"\t*ht = max(lh, rh) + 1;",
"\tif (abs(lh - rh) <= 1)",
"\t{",
"\t\treturn true;",
"\t}",
"\telse",
"\t{",
"\t\treturn false;",
"\t}",
"}"
],
"description": "Tree Balanced or Not Optimized"
},
"Flatten Binary Tree": {
"prefix": "flatten",
"body": [
"void flatten(Node *root)",
"{",
"\tif (root == NULL || (root->left == NULL || root->right == NULL))",
"\t{",
"\t\treturn;",
"\t}",
"",
"\tif (root->left != NULL)",
"\t{",
"\t\tflatten(root->left);",
"",
"\t\tNode *temp = root->right;",
"\t\troot->right = root->left;",
"\t\troot->left = NULL;",
"",
"\t\tNode *t = root->right;",
"",
"\t\twhile (t->right != NULL)",
"\t\t{",
"\t\t\tt = t->right;",
"\t\t}",
"\t\tt->right = temp;",
"\t}",
"\tflatten(root->right);",
"}"
],
"description": "Flatten Binary Tree"
}
}