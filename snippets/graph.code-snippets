{
"Adjacency Matrix in Graph": {
"prefix": "adjMatrix",
"body": [
"void adjMatrix()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tint adj[n + 1][n + 1];",
"\tfor (int i = 0; i <= n; i++)",
"\t{",
"\t\tfor (int j = 0; j <= n; j++)",
"\t\t{",
"\t\t\tadj[i][j] = 0;",
"\t\t}",
"\t}",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u][v] = 1;",
"\t\tadj[v][u] = 1;",
"\t}",
"\tfor (int i = 0; i <= n; i++)",
"\t{",
"\t\tfor (int j = 0; j <= n; j++)",
"\t\t{",
"\t\t\tcout << adj[i][j] << \" \";",
"\t\t}",
"\t\tcout << endl;",
"\t}",
"}"
],
"description": "Adjacency Matrix in Graph"
},
"Adjacency List in Graph": {
"prefix": "adjList",
"body": [
"void adjList()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<vector<int>> adj(n);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t\tadj[v].pb(u);",
"\t}",
"\tfor (int i = 0; i < adj.size(); i++)",
"\t{",
"\t\tcout << i << \"->\";",
"\t\tfor (auto x : adj[i])",
"\t\t{",
"\t\t\tcout << x << \" \";",
"\t\t}",
"\t\tcout << endl;",
"\t}",
"}"
],
"description": "Adjacency List in Graph"
},
"BFS in Graph": {
"prefix": "bfs",
"body": [
"void BFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<bool> vis(n + 1, false);",
"\tvector<vector<int>> adj(n + 1);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t\tadj[v].pb(u);",
"\t}",
"\tqueue<int> q;",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tif (!vis[i])",
"\t\t{",
"",
"\t\t\tq.push(i);",
"\t\t\tvis[i] = true;",
"\t\t\twhile (!q.empty())",
"\t\t\t{",
"\t\t\t\tint node = q.front();",
"",
"\t\t\t\tq.pop();",
"\t\t\t\tcout << node << \" \";",
"\t\t\t\tfor (auto x : adj[node])",
"\t\t\t\t{",
"\t\t\t\t\tif (!vis[x])",
"\t\t\t\t\t{",
"\t\t\t\t\t\tvis[x] = true;",
"\t\t\t\t\t\tq.push(x);",
"\t\t\t\t\t}",
"\t\t\t\t}",
"\t\t\t}",
"\t\t}",
"\t}",
"}"
],
"description": "BFS in Graph"
},
"DFS in Graph": {
"prefix": "dfs",
"body": [
"void dfs(int node, vector<vector<int>> adj, vector<bool> &vis)",
"{",
"\tvis[node] = true;",
"\tcout << node << \" \";",
"\tfor (auto x : adj[node])",
"\t{",
"\t\tif (vis[x])",
"\t\t{",
"\t\t\t;",
"\t\t}",
"\t\telse",
"\t\t{",
"\t\t\tdfs(x, adj, vis);",
"\t\t}",
"\t}",
"}",
"void DFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<bool> vis(n + 1, false);",
"\tvector<vector<int>> adj(n + 1);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t\tadj[v].pb(u);",
"\t}",
"",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tif (!vis[i])",
"\t\t{",
"",
"\t\t\tdfs(i, adj, vis);",
"\t\t}",
"\t}",
"}"
],
"description": "DFS in Graph"
},
"Topological BFS in Graph": {
"prefix": "topoBfs",
"body": [
"void TopoBFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<vector<int>> adj(n);",
"\tvector<int> indeg(n, 0);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t\tindeg[v]++;",
"\t}",
"\tqueue<int> q;",
"\tfor (int i = 0; i < indeg.size(); i++)",
"\t{",
"\t\tif (indeg[i] == 0)",
"\t\t{",
"\t\t\tq.push(i);",
"\t\t}",
"\t}",
"",
"\twhile (!q.empty())",
"\t{",
"\t\tint node = q.front();",
"",
"\t\tq.pop();",
"\t\tcout << node << \" \";",
"\t\tfor (auto x : adj[node])",
"\t\t{",
"\t\t\tindeg[x]--;",
"\t\t\tif (indeg[x] == 0)",
"\t\t\t{",
"\t\t\t\tq.push(x);",
"\t\t\t}",
"\t\t}",
"\t}",
"}"
],
"description": "Topological BFS in Graph"
},
"Topological DFS in Graph": {
"prefix": "topoDfs",
"body": [
"void Topodfs(int node, vector<vector<int>> adj, vector<bool> &vis, stack<int> &st)",
"{",
"\tvis[node] = true;",
"\tfor (auto x : adj[node])",
"\t{",
"\t\tif (vis[x])",
"\t\t{",
"\t\t\t;",
"\t\t}",
"\t\telse",
"\t\t{",
"\t\t\tTopodfs(x, adj, vis, st);",
"\t\t}",
"\t}",
"\tst.push(node);",
"}",
"void TopoDFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<bool> vis(n + 1, false);",
"\tvector<vector<int>> adj(n + 1);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t}",
"\tstack<int> st;",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tif (!vis[i])",
"\t\t{",
"",
"\t\t\tTopodfs(i, adj, vis, st);",
"\t\t}",
"\t}",
"\twhile (!st.empty())",
"\t{",
"\t\tint ans = st.top();",
"\t\tcout << ans << \" \";",
"\t\tst.pop();",
"\t}",
"}"
],
"description": "Topological DFS in Graph"
},
"Is Cycle is Present in Graph using DFS": {
"prefix": "isCycleDfs",
"body": [
"bool isCycle(int s, vector<vector<int>> &adj, vector<bool> &vis, int parent)",
"{",
"\tvis[s] = true;",
"\tfor (auto x : adj[s])",
"\t{",
"\t\tif (x != parent)",
"\t\t{",
"\t\t\tif (vis[x])",
"\t\t\t{",
"\t\t\t\treturn true;",
"\t\t\t}",
"\t\t\tif (!vis[x] && isCycle(x, adj, vis, s))",
"\t\t\t{",
"\t\t\t\treturn true;",
"\t\t\t}",
"\t\t}",
"\t}",
"\treturn false;",
"}",
"void CycleDFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<bool> vis(n, false);",
"\tvector<vector<int>> adj(n);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t}",
"",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tif (!vis[i] && isCycle(i, adj, vis, -1))",
"\t\t{",
"",
"\t\t\tcout << true << endl;",
"\t\t\treturn;",
"\t\t}",
"\t}",
"\tcout << false << endl;",
"}"
],
"description": "Is Cycle is Present in Graph using DFS"
},
"Is Cycle is Present in Graph using BFS": {
"prefix": "isCycleBfs",
"body": [
"void CycleBFS()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<vector<int>> adj(n);",
"\tvector<int> indeg(n, 0);",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v;",
"\t\tcin >> u >> v;",
"\t\tadj[u].pb(v);",
"\t\tindeg[v]++;",
"\t}",
"\tqueue<int> q;",
"\tfor (int i = 0; i < indeg.size(); i++)",
"\t{",
"\t\tif (indeg[i] == 0)",
"\t\t{",
"\t\t\tq.push(i);",
"\t\t}",
"\t}",
"\tint count = 0;",
"\twhile (!q.empty())",
"\t{",
"\t\tint node = q.front();",
"",
"\t\tq.pop();",
"\t\tfor (auto x : adj[node])",
"\t\t{",
"\t\t\tindeg[x]--;",
"\t\t\tif (indeg[x] == 0)",
"\t\t\t{",
"\t\t\t\tq.push(x);",
"\t\t\t}",
"\t\t}",
"\t}",
"\tif (count != n)",
"\t{",
"\t\tcout << true << endl;",
"\t}",
"\telse",
"\t{",
"\t\tcout << false << endl;",
"\t}",
"}"
],
"description": "Is Cycle is Present in Graph using BFS"
},
"Shortest Path Direct Acyclic Graph": {
"prefix": "shortesPathDAG",
"body": [
"void TopodfsDAG(int node, vector<pair<int, int>> adj[], vector<bool> &vis, stack<int> &st)",
"{",
"\tvis[node] = true;",
"\tfor (auto x : adj[node])",
"\t{",
"\t\tif (!vis[x.first])",
"\t\t{",
"\t\t\tTopodfsDAG(x.first, adj, vis, st);",
"\t\t}",
"\t}",
"\tst.push(node);",
"}",
"void shortesPathDAG()",
"{",
"\tint n, m;",
"\tcin >> n >> m;",
"\tvector<bool> vis(n + 1, false);",
"\tvector<pair<int, int>> adj[n];",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v, w;",
"\t\tcin >> u >> v >> w;",
"\t\tadj[u].pb({v, w});",
"\t}",
"\tint src;",
"\tcin >> src;",
"\tstack<int> st;",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tif (!vis[i])",
"\t\t{",
"",
"\t\t\tTopodfsDAG(i, adj, vis, st);",
"\t\t}",
"\t}",
"\tint dist[n];",
"\tfor (int i = 0; i < n; i++)",
"\t{",
"\t\tdist[i] = INT_MAX;",
"\t}",
"\tdist[src] = 0;",
"\twhile (!st.empty())",
"\t{",
"\t\tint node = st.top();",
"\t\tst.pop();",
"\t\tif (dist[node] != INT_MAX)",
"\t\t{",
"\t\t\tfor (auto x : adj[node])",
"\t\t\t{",
"\t\t\t\tif (dist[x.first] > dist[node] + x.second)",
"\t\t\t\t{",
"\t\t\t\t\tdist[x.first] = dist[node] + x.second;",
"\t\t\t\t}",
"\t\t\t}",
"\t\t}",
"\t}",
"\tfor (int i = 0; i < n; i++)",
"\t\t(dist[i] == INT_MAX) ? cout << \"INFINITY \" : cout << dist[i] << \" \";",
"}"
],
"description": "Shortest Path Direct Acyclic Graph"
},
"Dijsktra Algorithm": {
"prefix": "dijsktra",
"body": [
"void dijsktra()",
"{",
"\tint n, m, source;",
"\tcin >> n >> m;",
"\tvector<pair<int, int>> g[n + 1];",
"",
"\tint a, b, wt;",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tcin >> a >> b >> wt;",
"\t\tg[a].push_back(make_pair(b, wt));",
"\t\tg[b].push_back(make_pair(a, wt));",
"\t}",
"\tcin >> source;",
"",
"\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
"\tvector<int> disTo(n + 1, INT_MAX);",
"",
"\tdisTo[source] = 0;",
"",
"\tpq.push(make_pair(0, source));",
"",
"\twhile (!pq.empty())",
"\t{",
"\t\tint dist = pq.top().first;",
"\t\tint prev = pq.top().second;",
"\t\tpq.pop();",
"",
"\t\tvector<pair<int, int>>::iterator it;",
"",
"\t\tfor (it = g[prev].begin(); it != g[prev].end(); it++)",
"\t\t{",
"\t\t\tint next = it->first;",
"\t\t\tint nextDist = it->second;",
"",
"\t\t\tif (disTo[next] > disTo[prev] + nextDist)",
"\t\t\t{",
"\t\t\t\tdisTo[next] = disTo[prev] + nextDist;",
"\t\t\t\tpq.push(make_pair(disTo[next], next));",
"\t\t\t}",
"\t\t}",
"\t}",
"\tcout << \"The distances from source, \" << source << \", are : \" << endl;",
"\tfor (int i = 1; i <= n; i++)",
"\t{",
"\t\tcout << disTo[i] << \" \";",
"\t}",
"\tcout << endl;",
"}"
],
"description": "Dijsktra Algorithm"
},
"BellmanFord Algorithm": {
"prefix": "bellmanFord",
"body": [
"void bellmanFord()",
"{",
"\tint N, m;",
"\tcin >> N >> m;",
"\tvector<node> edges;",
"\tfor (int i = 0; i < m; i++)",
"\t{",
"\t\tint u, v, wt;",
"\t\tcin >> u >> v >> wt;",
"\t\tedges.push_back(node(u, v, wt));",
"\t}",
"\tint src;",
"\tcin >> src;",
"",
"\tint inf = 1e9;",
"\tvector<int> dist(N, inf);",
"\tdist[src] = 0;",
"",
"\tfor (int i = 0; i <= N - 1; i++)",
"\t{",
"\t\tfor (auto it : edges)",
"\t\t{",
"\t\t\tif (dist[it.u] + it.wt < dist[it.v])",
"\t\t\t{",
"\t\t\t\tdist[it.v] = dist[it.u] + it.wt;",
"\t\t\t}",
"\t\t}",
"\t}",
"\tint fl = 0;",
"\tfor (auto it : edges)",
"\t{",
"\t\tif (dist[it.u] + it.wt < dist[it.v])",
"\t\t{",
"\t\t\tcout << \"NegativeCycle\" << endl;",
"\t\t\tfl = 1;",
"\t\t\tbreak;",
"\t\t}",
"\t}",
"\tif (!fl)",
"\t{",
"\t\tfor (int i = 0; i < N; i++)",
"\t\t{",
"\t\t\tcout << i << \" \" << dist[i] << endl;",
"\t\t}",
"\t}",
"}"
],
"description": "BellmanFord Algorithm"
}
}
